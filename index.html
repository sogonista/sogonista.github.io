# ライブラリを変更
import streamlit as st 
from pydub import AudioSegment 
from faster_whisper import WhisperModel 
import os
import subprocess
import pandas as pd
import base64
from io import BytesIO
import tempfile  # 一時的に音声データを保存

# 環境設定
os.environ["KMP_DUPLICATE_LIB_OK"] = "TRUE"

def download_youtube_audio(yt_url, temp_file):  
    """youtubeをダウンロードして音声データに変換する関数"""
    cmd = [
        'yt-dlp',
        '-x',
        '--audio-format', 'mp3',
        yt_url,
        '-o', temp_file.name  
    ]
    subprocess.run(cmd)
    return temp_file.name

def transcribe_audio(audio_path):
    """音声データをlarge-v2(cpu)で文字起こしする関数"""
    model_size = "large-v2"
    model = WhisperModel(model_size, device="cpu", compute_type="int8")
    segments, info = model.transcribe(audio_path, beam_size=5)
    return segments, info

def convert_audio_to_mp3(input_path):
    """音声データをmp3に変更し、一時的に保存する関数"""
    audio = AudioSegment.from_file(input_path)
    with tempfile.NamedTemporaryFile(suffix=".mp3", delete=False) as temp:  
        audio.export(temp.name, format="mp3")
        return temp.name

def audio_segment_to_base64(audio_path, start_time, end_time):
    """特定の区間の音声をbase64エンコードとして返す関数"""
    audio = AudioSegment.from_file(audio_path)
    extract = audio[start_time * 1000:end_time * 1000]

    buffer = BytesIO()
    extract.export(buffer, format="mp3")
    buffer.seek(0)
    audio_base64 = base64.b64encode(buffer.getvalue()).decode('utf-8')
    return audio_base64

def main():
    """streamlitアプリのメイン関数"""

    st.title("動画音声の文字起こしアプリ")

    url = st.text_input('YouTube リンクを入力してください:')
    file = st.file_uploader('または動画ファイルをアップロードしてください:', type=['mp4', 'wav', 'mp3', 'flv', 'ogg', 'webm', 'mov'])

    if url or file:
        if url:
            st.write("動画をダウンロードしています...")
            with tempfile.NamedTemporaryFile(suffix=".mp3", delete=False) as temp:  
                audio_path = download_youtube_audio(url, temp)
        else:
            with tempfile.NamedTemporaryFile(suffix=f".{file.type.split('/')[-1]}", delete=False) as temp:  
                temp.write(file.getvalue())
                if file.type == "audio/mp3":
                    audio_path = temp.name
                else:
                    audio_path = convert_audio_to_mp3(temp.name)
        
        # 文字起こし中の表示
        st.write("文字起こしを実行中...")
        segments, info = transcribe_audio(audio_path)

        # 検出された言語を表示
        st.write(f"検出された言語: '{info.language}' 確率: {info.language_probability:.2f}")

        # 時間と文字起こし結果を表示
        segments_data = []

        for index, segment in enumerate(segments):
            time_range = f"{segment.start:.2f}s"
            segments_data.append([time_range, segment.text])

            audio_base64 = audio_segment_to_base64(audio_path, segment.start, segment.end)
            audio_player_html = f'<audio controls><source src="data:audio/mp3;base64,{audio_base64}"></audio>'
            
            with st.container():
                st.markdown(audio_player_html, unsafe_allow_html=True)
                # st.write(f"{time_range}  {segment.text}")
                # 薄い緑色で出力する
                st.write(f'<span style="background-color: #e0f2f1;">{time_range}  {segment.text}</span>', unsafe_allow_html=True)

        # ここから音声と時間とテキストをセル形式で表示する
        # ここから音声と時間とテキストをセル形式で表示する
        # ここから音声と時間とテキストをセル形式で表示する

        # for index, segment in enumerate(segments):
        #     time_range = f"{segment.start:.2f}s"
        #     text_range = f"{segment.text}"

        #     audio_base64 = audio_segment_to_base64(audio_path, segment.start, segment.end)
        #     audio_player_html = f'<audio controls><source src="data:audio/mp3;base64,{audio_base64}"></audio>'

        #     # 編集可能なテキストボックスで時間とテキストを表示・編集
        #     with st.container():
        #         st.markdown(audio_player_html, unsafe_allow_html=True)
        #         col1, col2, col3 = st.columns([1, 2, 5])
        #         edited_time = col1.text_input(f"Time {index}", value=time_range)
        #         edited_text = col3.text_area(f"Text {index}", value=text_range, height=100)

        #         # 初回はリストにデータを追加
        #         segments_data.append([edited_time, edited_text])
                
        # 編集したデータをCSVで保存
        df = pd.DataFrame(segments_data, columns=["Time", "Text"])
        csv = df.to_csv(index=False)
        b64 = base64.b64encode(csv.encode()).decode()
        st.markdown(f'<a href="data:file/csv;base64,{b64}" download="transcribed_text.csv">Download CSV File</a>', unsafe_allow_html=True)

        # 削除する
        os.remove(audio_path)


# アプリを起動します
if __name__ == "__main__":
    main()
